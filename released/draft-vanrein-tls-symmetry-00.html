<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Symmetry for Transport Layer Security</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 The role_preference TLS Extension"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Procedures"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Sending ClientHello with role_preference"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Receiving ClientHello with role_preference"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Not Receiving ClientHello with role_preference"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Sending ServerHello"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Configuring TLS for Symmetric Behaviour"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Efficiency Considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Privacy Considerations"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations"/>
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="9 Normative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.4.8 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Van Rein, R." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-vanrein-tls-symmetry-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2015-9-4" />
  <meta name="dct.abstract" content="TLS connections can be run over various transports, and can in turn carry many application protocols.  All current transports and at least some application protocols are capable of running between symmetric end points, in what could be called peer-to-peer mode, but the use of TLS introduces a requirement to always assign a client and server role, thus enforcing asymmetry and complicating symmetric peer-to-peer protocols.  This specification defines a TLS Extension to remedy that stringency of TLS." />
  <meta name="description" content="TLS connections can be run over various transports, and can in turn carry many application protocols.  All current transports and at least some application protocols are capable of running between symmetric end points, in what could be called peer-to-peer mode, but the use of TLS introduces a requirement to always assign a client and server role, thus enforcing asymmetry and complicating symmetric peer-to-peer protocols.  This specification defines a TLS Extension to remedy that stringency of TLS." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">R. Van Rein</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">ARPA2.net</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">September 4, 2015</td>
</tr>
<tr>
  <td class="left">Expires: March 7, 2016</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Symmetry for Transport Layer Security<br />
  <span class="filename">draft-vanrein-tls-symmetry-00</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>TLS connections can be run over various transports, and can in turn carry many application protocols.  All current transports and at least some application protocols are capable of running between symmetric end points, in what could be called peer-to-peer mode, but the use of TLS introduces a requirement to always assign a client and server role, thus enforcing asymmetry and complicating symmetric peer-to-peer protocols.  This specification defines a TLS Extension to remedy that stringency of TLS.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 7, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2015 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">The role_preference TLS Extension</a></li>
<li>3.   <a href="#rfc.section.3">Procedures</a></li>
<li>3.1.   <a href="#rfc.section.3.1">Sending ClientHello with role_preference</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Receiving ClientHello with role_preference</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Not Receiving ClientHello with role_preference</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Sending ServerHello</a></li>
<li>4.   <a href="#rfc.section.4">Configuring TLS for Symmetric Behaviour</a></li>
<li>5.   <a href="#rfc.section.5">Efficiency Considerations</a></li>
<li>6.   <a href="#rfc.section.6">Privacy Considerations</a></li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a></li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a></li>
<li>9.   <a href="#rfc.references">Normative References</a></li>
<li><a href="#rfc.authors">Author's Address</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a></h1>
<p id="rfc.section.1.p.1">TLS secures many application protocols, some of which can be run symmetrically between peers, possibly after discovery through a mechanism such as mDNS.  The introduction of TLS as a security layer underneath application protocols enforces the assignment of asymmetric client and server roles, something that not all protocols were designed to negotiate.  Examples of application protocols that do not suggest client and server roles for end points include XMPP and SIP in peer-to-peer mode, or some uses of the symmetric MSRP protocol.  In addition, there are many non-standard protocols that have been designed to operate symmetrically from the ground up because they are meant for peer-to-peer operation.</p>
<p id="rfc.section.1.p.2">TLS can be carried over transports UDP, TCP and SCTP, sometimes in the DTLS variation.  It is commonly understood that UDP can be initiated from either or both sides, but it is less well-known that TCP and SCTP may also connect between two active end points; in this situation both end points initiate the connection, and as a result of network communication delays these attempts cross midway.  And indeed, this is even a practically possible situation when one or both end points have a known address, for instance as a result of prior exchange of transparent addresses.  Furthermore, firewalls and other middle boxes tend to faithfully implement the TCP state diagrams [Figure 6 of <a href="#RFC0793">[RFC0793]</a>] that enable this connection setup between two active end points.  Lacking an obvious active and passive side for at least some transport connections means that this is not always available as a tie-breaker to assign TLS client and TLS server rolese.</p>
<p id="rfc.section.1.p.3">The need to authenticate a remote peer may help to decide which side must play the role of client, and which is to be the server.  But in situations with mutual authentication using a more-or-less symmetric CipherSuite, this last reason for asymmetric client/server role separation may also be unsuitable.</p>
<p id="rfc.section.1.p.4">This specification introduces a TLS Extension that can be used to indicate that the client/server role assignment is open for negotiation as part of the TLS handshake.  This is helpful for those situations where these roles cannot be derived from the context, as described above.  It can also be used by a TLS server that wants to actively initiate a connection to a TLS client, and even by a TLS end point that wants to open a hole in its local firewall.</p>
<p id="rfc.section.1.p.5">The protocol flow then allows both end points to send a ClientHello containing the new TLS Extension, and based on a tie-breaker value in that extension each party reaches the same conclusion on which TLS end point continues as a client, and which continues as a server.  The following figure demonstrates how the resulting TLS flow looks.</p>
<pre>
ClientHello                  &lt;-------&gt;          ClientHello

                                                ServerHello
                                          ServerKeyExchange
                             &lt;--------      ServerHelloDone
ClientKeyExchange
[ChangeCipherSpec]
Finished                     --------&gt;
                                         [ChangeCipherSpec]
                             &lt;--------             Finished

Application Data             &lt;-------&gt;     Application Data
</pre>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#extdef" id="extdef">The role_preference TLS Extension</a></h1>
<p id="rfc.section.2.p.1">The role_preference extension carries a byte sequence of at least 1 byte and at most 32 bytes in its extension_data field; each of the bytes must have a value of at least 33 and no more than 126; this makes the byte sequences suitable for treatment as case-sensitive ASCII strings; it should however be noted that these strings have no terminating NUL character.</p>
<p id="rfc.section.2.p.2">These role_preference values may be compared on a byte-by-byte basis to determine whether one is ordered before another.  The first byte value that differs determines which of the strings is ordered before the other; and if one string equals the other but has additional bytes then the shorter is ordered before the longer one.  When one role_preference values is exactly the same as another, they are said to be ordered as equals.  When one role_preference value is neither ordered before, nor as an equal to another, then the one is said to be ordered after the other.</p>
<p id="rfc.section.2.p.3">An easy way to remember these ordering rules is that "client" is ordered before "server"; and this hints at the intention: if one role_preference value is ordered before another, then the party who sent the one value should take on the role of TLS client, whereas the party that sent the other value should take on the role of TLS server.  When two role_preference are ordered as equals then the surrounding TLS handshake fails, on grounds of not being able to establish a client/server role distinction, which should be reported through a handshake_failure alert.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#proc" id="proc">Procedures</a></h1>
<p id="rfc.section.3.p.1">This section defines procedures for sending ClientHello and processing the reception of one.</p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#send" id="send">Sending ClientHello with role_preference</a></h1>
<p id="rfc.section.3.1.p.1">A ClientHello with the role_preference extension may be sent once by each of the peers, as the initiation of a TLS handshake.  The order in which the sides send this extension is arbitrary.  It is only possible to send a ClientHello with the role_preference as the first record in a TLS handshake, either on a fresh connection or during (secure) renegotiation.</p>
<p id="rfc.section.3.1.p.2">It is considered an error condition when both sides send a ClientHello but not both incorporate the role_preference extension.  This situation MUST result in a handshake_error alert, and may be the cause for a new attempt over a new connection.  A more conservative approach would be for a TLS end point to wait for a ClientHello from the remote end point and see if the extension is present; this can work if the remote TLS end point is known to be able to act as a client.  Context, historic behaviour and the application protocol can all be helpful determine the most useful approach here.</p>
<p id="rfc.section.3.1.p.3">The role_preference value comprising of a single byte valued 33 will never have a value ordered before it; this can be sent to require a client role.  The role_preference value comprising of 32 bytes, all valued 126, will never have a value ordered after it; this can be sent to require a server role.  When both sides require the same role, a handshake_error alert will be the result.</p>
<p id="rfc.section.3.1.p.4">When a TLS end point is neutral about its role as a client or a server, it can send any value in between, and it should send a random value to achieve a high probabily of being compatible with any remote TLS end point.  The probability of running into a random value from the remote that happens to be the same will be negligable for long enough extension values.</p>
<p id="rfc.section.3.1.p.5">Other details in the ClientHello, such as a Server Name Indication and listed CipherSuites, SHALL be representative only of a potential client role; the TLS end point that ends up in the server role will send a ServerHello with new information.</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#recv" id="recv">Receiving ClientHello with role_preference</a></h1>
<p id="rfc.section.3.2.p.1">When a ClientHello with the role_preference extension is received and a ClientHello has not been sent yet, then a ClientHello with the role_preference must still be sent.  Only TLS implementations or configurations that do not support the role_preference extension would not send this ClientHello.</p>
<p id="rfc.section.3.2.p.2">After a ClientHello with role_preference is both sent and received, their values can be ordered.  When the extension value sent is ordered before the extension value received, the local side will continue as a TLS client and the ClientHello sent continues as the ClientHello record for the TLS handshake, whereas the ClientHello received is strikken from the TLS handshake.  When the extension value sent is ordered after the extension value received, the local side will continue as a TLS server and the received ClientHello continues as the ClientHello record for the TLS Handshake, whereas the ClientHello sent is strikken from the TLS handshake.  When the extension values sent and received are ordered as equals, a handshake_error alert is locally processed as though it had been received over the TLS connection.</p>
<p id="rfc.section.3.2.p.3">When a ClientHello mesage is strikken from the TLS handshake, the following can be said: </p>

<ul>
  <li>All the information contained in the strikken ClientHello message is forgotten.</li>
  <li>The random material in the strikken ClientHello message is therefore also dropped; the same random material may however be used in the ServerHello, since that is sent by the same party and because it impacts further security mechanisms in the same manner.</li>
  <li>The strikken ClientHello message has no security impact; even the selection of the role is not a security matter, since that is already customarily done outside the protected scope of TLS.  As a result, the strikken ClientHello message is not taken into account when constructing the handshake_messages for the Finished message [Section 7.4.9 of <a href="#RFC5246">[RFC5246]</a>] or other messages.  In other words, the handshake_messages are formed from the traditional sequence ClientHello, ServerHello, ...</li>
</ul>

<p> </p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#norecv" id="norecv">Not Receiving ClientHello with role_preference</a></h1>
<p id="rfc.section.3.3.p.1">When a ClientHello with the role_preference extension has been sent, but the remote TLS end point respondes with a ClientHello without role_preference extension, then a handshake_error alert MUST be raised, as the handshake procedure was not properly adapted to this specification.</p>
<p id="rfc.section.3.3.p.2">When a ClientHello with the role_preference extension has been sent, but the remote TLS end point responds with a ServerHello, it is clear that no ClientHello is to be expected.  The conclusion is then that the remote TLS end point does not implement the role_preference extension.   In this case, the handshake continues as it would have without the role_preference extension; the TLS end point that sent the ClientHello continues as a client and the TLS end point that responded with a ServerHello continues as a server.</p>
<p id="rfc.section.3.3.p.3">As an exception to the last paragraph, there is the situation where the role_preference was set to require a server role.  In this case, a ServerHello response from the remote TLS end point SHOULD be considered an error, and will raise the handshake_error alert.  Note that this is actually a new use case, where a server sends a ClientHello and expects the other side to initiate a client connection on its initiative; this is not part of the usual TLS flow, so it does not dismantle any of the normal TLS usage patterns.</p>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#srvhello" id="srvhello">Sending ServerHello</a></h1>
<p id="rfc.section.3.4.p.1">When one of the TLS end points has been selected to fulfil the server role, it will send the usual ServerHello.  ServerHello messages MUST NOT include the role_preference extension, as this has already been acknowledged in the ClientHello response preceeding the ServerHello.</p>
<p id="rfc.section.3.4.p.2">In fact, the ServerHello and all follow-up messages conform to the existing TLS procedures.  Only when renegotiating TLS with a new handshake will the possibility of change of roles come up again.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#config" id="config">Configuring TLS for Symmetric Behaviour</a></h1>
<p id="rfc.section.4.p.1">The role_preference extension MUST NOT be sent by default by a general TLS implementation.  Only when it is implemented with the possibility of symmetric peers in mind, or when it is explicitly configured to permit this mode of operation, SHOULD the role_preference extension be sent.</p>
<p id="rfc.section.4.p.2">Most current applications of TLS are aware of client and server roles, and will specify their authentication and encryption requirements in those terms.  For example, it is often assumed that a client does not offer authentication, but that a server will authenticate to the client.  The client thereby becomes the responsible party to detect man-in-the-middle attacks, because the server cannot distinguish an honest client from a rogue one.  Note that this protocol flow is asymmetric, and as a result so is its configuration.</p>
<p id="rfc.section.4.p.3">When welcoming both client and server roles, the TLS implementation conceals the actual client and server role assignment, and the application using it will be considered as a symmetric peer.  This has an impact on the configuration, which must now speak in terms of local and remote configuration, instead of in terms of client and server configuration.  Not all CipherSuites are equally suited for this mode of operation, but use cases that require mutual authentication are reasonably well-supported, and are also the most likely for symmetric peer-to-peer applications of TLS.</p>
<p id="rfc.section.4.p.4">During renegotiation of the handshake, the roles of client and server may be swapped.  This process is asynchronous to the application-level protocol, and MUST NOT be permitted by default, unless it is explicitly configured from code that is aware of the application protocol's assumptions.</p>
<p id="rfc.section.4.p.5">TLS implementations that can end up being either a client or a server SHOULD permit separate configuration of the various parameters that are negotiated during the ClientHello, ServerHello handshake.  They should permit separate CipherSuite lists for the two roles, for instance, and their use of Server Name Indications and other extensions may also differ between the two roles.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#efficiency" id="efficiency">Efficiency Considerations</a></h1>
<p id="rfc.section.5.p.1">The TLS changes specified here introduce one more message to the TLS handshake.  When this message is generated asynchronously, there is no need for an extra roundtrip, as both sides simply start sending it as soon as the connection comes up.  Whether this is safe depends in part on the application protocol; symmetric peer-to-peer protocols will often be able to assume support for the extension.</p>
<p id="rfc.section.5.p.2">When the extension is negotiated by a side that defaults to the client role, then a side that defaults to the server role would await it and be required to send the additional ClientHello in its response to indicate support for the role_preference extension.  If this response lets the sides take on their default roles, then no extra roundtrip is required because the additional ClientHello can be sent together with the ServerHello that immediately follows it.  If the response switches sides, then half a roundtrip is added, as the sides switch their roles.  The added flexbility of making this switch may be considered sufficiently valuable to invest this half roundtrip time.</p>
<p id="rfc.section.5.p.3">The generated random values for the role_preference extension need not be cryptographically secure values; they merely exist as a tie-breaker in the client/role appointment.  This can be achieved with a lower quality random number generator, which can be implemented more efficiently than a secure random number generator.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#privacy" id="privacy">Privacy Considerations</a></h1>
<p id="rfc.section.6.p.1">The ClientHello sent by the server provides additional information, such as the CipherSuites acceptable to the server when it ends up in client mode, and extension information such as a Server Name Indication.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#security" id="security">Security Considerations</a></h1>
<p id="rfc.section.7.p.1">This specification introduces more dynamicity to TLS, and that is automatically a concern.  The additional flexibility is not advised as a default mode of operation for general TLS implementations, to avoid interfering with the assumptions made by applications about strict client/server behaviour of TLS.</p>
<p id="rfc.section.7.p.2">Applications that are aware of their potential to be either a TLS client or a TLS server should be mindful, and select separate configuration settings for each role.  It may be helpful to permit configuration to take place in terms of requirements of authenticating the remote end.  And, just as any TLS configuration should take the possibility of NULL CipherSuites into account, it should also be aware of the impact of the various CipherSuites on the two roles to be played.</p>
<p id="rfc.section.7.p.3">In a symmetric peer-to-peer application, it makes some sense to consider both the client and server role, and setup for each separately.  This work is otherwise done separately on each end, but symmetric peer-to-peer protocols tend to connect in both directions and therefore already require both configurations to be defined.  This has not changed; what has changed is that the application is not necessarily aware of which applies.</p>
<p id="rfc.section.7.p.4">Having said that, most TLS implementations will not conceal the chosen role completely, because many application protocols need to know about it.</p>
<p id="rfc.section.7.p.5">A concern that TLS end points must be aware of when permitting changes of role, is that there may sometimes be a reason to renegotiate the handshake, in which case the client has a decisive role, whereas the server can only ask the client.  Whether this could be problematic is an application-level decision to be taken into account before enabling the role_preference extension.</p>
<p id="rfc.section.7.p.6">It is also worth noting that the renegotiation provides an opportunity for change of the appointment of client and server roles.  This may happen in a manner that is asynchronous to the application-layer protocol.  This may or may not be a desired effect, which is why it is recommended as an explicit option to configure, defaulting towards the conservative option of not permitting a change of the roles.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#iana" id="iana">IANA Considerations</a></h1>
<p id="rfc.section.8.p.1">This specification defines a TLS extension, to be registered by IANA in the TLS Extensions Registry, ExtensionType Values subregistry.  The Extension Name to be used is role_preference.</p>
<h1 id="rfc.references"><a href="#rfc.references">9.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC0793">[RFC0793]</b>
      </td>
      <td class="top"><a>Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, August 2008.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Rick van Rein</span> 
	  <span class="n hidden">
		<span class="family-name">Van Rein</span>
	  </span>
	</span>
	<span class="org vcardline">ARPA2.net</span>
	<span class="adr">
	  <span class="vcardline">Haarlebrink 5</span>

	  <span class="vcardline">
		<span class="locality">Enschede</span>,  
		<span class="region">Overijssel</span> 
		<span class="code">7544 WP</span>
	  </span>
	  <span class="country-name vcardline">The Netherlands</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:rick@openfortress.nl">rick@openfortress.nl</a></span>

  </address>
</div>

</body>
</html>
